---
title: "Q&A宝典-ES6篇"
date: 2020-11-18
visitor: 28
categories:
- es6
tags:
- 复习,面试
isShowComments: true
---

<Boxx/>

# 第一篇 
## 一.Babel转码器的使用，ES6转ES5 
1. 安装babel：cnpm install babel/core --save
2. 配置.babelrc文件，该文件用来转置转码规则和插件
```
{
  "presets":[],
  "plugins":[]
}
```
3. 安装最新的转码规则
    * cnpm install @babel/preset-env --save
    * 在.babelrc里面配置转码规则
```
{
    "presets":["@babel/preset-env"],
    "plugins":[]
}
```
4. 安装转码命令：cnpm install @babel/cli --save-dev (dev表示开发环境下安装)
5. 命令行转码
    * 将转码结果显示在终端：npx babel example.js(待转码文件)
    * 将代码结果写入一个文件：npx babel example.js -o es5.js(转码后生成的文件)
    * 整个文件夹都转：npx babel src -d lib

## 二.解构赋值
1. 数组的解构赋值  
    * 说明：会按照对应的位置顺序进行解构
    * 用途：交换两个变量的值
    * 例如：
```
let [a,b,c]=[10,20,30]       =>a=10,b=20,c=30
let [a,b,c]=[10,20,30,40]    =>a=10,b=20,c=30  一一对应，40没有和他匹配的
let [a,b,,c]=[10,20,30,40]   =>a=10,b=20,c=40  一一对应，30匹配给了空，40匹配c

// 交换两个变量的值
var a=10;
var b=20;
[a,b]=[b,a]
```
2. 对象的解构赋值
    * 没有次序，一般变量必须和属性同名
    * 用途：不需要再用obj.key来拿到属性值，直接用name就行
    * 例如：
```
1. 变量和属性同名
var {name,age}={name:'beixi',age:'20'}    // 此时name就表示beixi   age就表示20

2. 变量和属性不同名
var {foo:baz}={foo:'aaa',bar:'bbb'}      // baz==='aaa' 真正赋值的是变量baz而不是foo匹配对象
```

## 三.字符串新增方法
1. str.includes('待查字符串')  
    * 说明：区别于str.indexOf('')  查到返回第一次出现的位置，查不到返回-1
    * 查到返回true,查不到返回false
2. str.startsWith(""): 返回布尔值用于检测待检字符串是否在原字符串的头部
3. str.endsWith(""):返回布尔值用于检测是否在原字符串的尾部
4. str.repeat(num):重复一个字符串，num向下取整 NaN,0到-1都视为0
5. str.padStart(param1,param2):用于头部补全
    * param1:补全长度（总长度）
    * param2:用于补全的参数
6. str.padEnd(param1,param2):用于尾部补全
    * param1:补全长度（总长度）
    * param2:用于补全的参数
7. str.trimStart():消除头部空格  返回一个新的字符串不会修改原字符串
8. str.trimEnd():消除尾部空格    返回一个新的字符串不会修改原字符串
9. str.trim():消除首尾的空格     返回一个新的字符串不会修改原字符串

## 四.数组扩展
1. 扩展运算符
    * 描述：将一个数组转化为用逗号分隔的参数序列。
    * 用途：浅拷贝和深拷贝，求最大值，数组合并，和解构赋值组等
    * 语法：
```
1. 代替apply求最大值
var arr=[1,5,8,56,98,23];
maxNumber1=Math.max.apply(null,arr)    // apply法
maxNumber2=Math.max(...arr)            // 扩展运算符法
console.log(maxNumber1,maxNumber2)

2. 复制数组
var arr1=[1,2,3];
var arr2=[...arr1]  深拷贝，是一个全新的数组，修改其中一个不会影响另一个

3. 数组合并
var arr1=[1,2,3];
var arr2=[4,5,6];
ES5：arr1.concat(arr2)
ES6:[...arr1,...arr2]

4. 与解构赋值组合
arr=[first,...arr]=[1,2,3,4]    // first===1,arr===[2,3,4]
```
2. 数组的方法
    * Array.from()  用于将一个伪数组转化为一个真正的数组  
        * 用途：`var arr2=Array from(arr1)=[...arr1]`  深拷贝arr1
    * Array.of()  用于将一组值转换为数组，主要是弥补Array()和new Array()的不足
        * Array(number):  只有一个参数number则表示是数组的长度是number，里面的元素都是empty
        * Array(a,b)=>[a,b]  也就是说，使用Array()来定义数组，则里面最少需要两个参数
    * find()和findIndex()
        * arr.find(function(){}) 数组成员依次执行回调函数找到第一个满足条件的值
        * arr.findIndex(function(){}) 数组成员依次执行回调函数找到第一个满足条件的值的位置
    * arr.fill(n,a,b)  填充数组,将原有的数值全部抹去，可见在初始化数组的时候非常方便
        * n:替换的值，a:起始位置  b：终止位置（不包括）
    * arr.keys() 拿到键;  arr.values()  拿到值;  arr.entries()  拿到键值对。
    * arr.includes()  返回一个布尔值用检测数组中是否包含被检测的元素
    * arr.flat(n):数组的扁平化，拉平。n表示拉平层数（嵌套几层拉几层） 生成了一个新的数组不改变原数组
    
## 五.函数扩展
1. 函数参数的默认值，直接给形参赋值
```
function f(a=10,b=20){
    return a+b
}
```
2. rest参数
    * 形式：（...变量）
    * 用于获取传递的多余参数
    * 例如：
```
function fun(...values){
    let sum=0;
    for (let i of values){
        sum+=i
    }  
    return sum
}
res=fun(2,3,5)
console.log(res)
```
3. 箭头函数
    * 当只有一个参数的时候（）可以省略，多个参数或者没有参数的时候不可以省略；
    * 当只有一个函数体的时候{}可以省略 
    * 不可以使用new关键字
    * 没有自己的arguments对象，如果需要传入多个参数则使用rest形式（...变量）
    * 不能使用yeild命令，因此不能使用generator函数
    * 没有this，需要通过查找作用域链的形式来确定this的值
4. 对象的扩展
    * Object.is(值1,值2)
        * 作用：返回一个布尔值，判断两个值是否相等
        * 特殊： Object.is(NaN,NaN) =>true;  Object.is(+0,-0)=>false
    * Object.assign(target,参数1,参数2,...)
        * 说明：对象的合并，第一个是目标对象，后面的都往后面的拼接
    * Object.keys(obj)
        * 作用：返回obj对象的键
    * Object.values(obj)
        * 作用：返回obj对象的值
    Object.entries(obj)
        * 作用：返回obj对象的键值    
        
## 六.symbol
1. 是es6中新增的一个基本数据类型  
2. 通过symbol定义的变量是一个独一无二的值，不会产生命名冲突问题，例如：`let s=Symbol()`
3. Symbol()函数不能使用new命令
4. Symbol()函数只表述对当前symbol值的描述，因此相同参数的symbol函数的返回值是不相同的
5. Symbol值不能与其他类型的值进行计算，否则会报错
  
## 七.set和map
1. set容器
    * 说明：本质上是一种数据结构，里面的值都是唯一的
    * 定义：`var set=new Set()`
    * 操作方法： 
        * 添加：set.add()
        * 删除：set.delete()
        * 检测返回一个布尔值表示该值是否是set成员：set.has()
        * 清除所有成员：set.clear()
        * set容器长度：set.size()
    * 用途：数组去重
        * Array.from(new Set(arr)) === (...new Set(arr))
2. map容器
    * 描述：本质上是一种数据结构类似于对象，键的范围不限于字符串，可以是各种类型包括是对象。
    * 定义：``var map=new Map()``
    * 操作方法：
        * map.set(key,value) 添加键值对
        * map.get(key)     获取键
        * map.delete(key)  删除键
        * map.has(key)     检测是否包含待检测键
        * map.clear()      清除map容器
        * map.size()       计算map容器的长度
        
## 八.增强for循环forEach
1. 说明：增强for循环，对每一项执行一次回调函数，拿到满足条件的值
2. 语法：``forEach(function(){})`` 
```
var set=new Set();
var arr=[1,2,3,4,5];
/*for(let i of arr){
set.add(i)
}*/
arr.forEach((i)=>{
set.add(i)
})
console.log(set);

```

## 九. 异步Promise
1. 地狱回调：在回调函数中继续使用回调函数，使得逻辑结构变得十分复杂。
2. 回调函数：一种解决异步编程的方法
3. promise
    * 描述：解决异步编程的一种优秀方案，经常使用在网络请求里面。
    * 作用：以同步的形式来解决异步编程中回调函数方法造成的地狱回调问题。
    * 使用：new Promise(resolve,reject)=>{待处理的异步操作}.then(data=>{}).catch(err=>{})
        * 说明：.then(data=>{})用来处理异步操作成功的结果。.catch(err=>{})用来处理异步操作失败的结果
    * 三种状态：
        * pending       异步操作处于进行中
        * fulfilled     异步操作已成功,马上执行.then()
        * rejected      异步操作失败了,马上执行.catch()
    * 语法:
```
new Promise((resolve,reject)=>{
    异步操作
    setTimeout(()=>{
        成功的时候调用
        resolve('我成功了')；
        失败的时候调用
        reject('我失败了')
    },1000)
}).then(res=>{}).catch(err=>{})
```
4. 多个promise请求
    * 使用Promise.all()进行封装
    * 语法：
```
Promise.all(
    new Promise(){},
    new Promise(){},...
).then(res=>{}).catch(err=>{})
res是多个结果组成的一个数组，再根据需要选择。
```
5. 利用Promise发送Ajax请求
```
const getFunction=function () {
    const promise=new Promise((resolve,reject)=>{
      // ajax网络异步请求
      $.ajax({
        type:'get',
        url,
        success:res=>{
          resolve(res)
        },
        error:err=>{
          reject(err)
        }
      })
    })
    return promise;
}
getFunction.then(res=>{
    console.log(res);
    // 再调用一次
    var url=res.Url;
    return getFunction(url)
}).catch(err=>{
    console.log(err);
}).then(()=>{})
```

## 十. 异步Generator
1. 说明：
    * Generator函数是一个状态机，内部封装了很多不同状态的数据。
    * 用来生成遍历器对象
    * 可以通过yield命令暂停，next命令启动。每次返回的结果是yield后面表达式的结果{value:'',done:'false/true'}的形式
      true和false表示Generator函数是否执行完毕
2. 作用：解决异步编程问题
3. 特点：
    * function 和函数名之间有一个*号
    * 内部用yield表达式来定义不同的状态
    * 函数返回的结果是一个指针对象，而不会执行函数内部的逻辑
    * 遇到yield停止执行，遇到next开始执行
    * yield语句返回的结果通常是Undefined
    * 参数是通过next(参数)来传递的
4. 语法：
```
function* generator(x){
    yield 'hello'     {value:'hello',done:'false'}
    var y=yield x+2
    return y
}
var g=generator(1)
g.next()
```
    
## 十一. 异步Async
1. 一种改进的异步操作（现在多使用这种方法）
2. 改良部分：
    * 不需要通过执行器，可以像普通函数一样被执行
    * 将Generator中的*换成了async，yield换成了await语义更加清楚了
    * async返回的结果是一个promise对象，这样也便于和.then()方法使用
    * await 可以看做是.then()命令的语法糖   
    * 唯一的难点就是对于错误机制的捕获
3. 利用async做异步请求：
```
async function getFunciton(){
    1. 用promise封装一个异步请求
    const promise=new Promise((resolve,reject)=>{
        setTimeout(()=>{
          resolve('执行成功')
        },1000)
    })
    return promise
}

2. 使用异步函数
var res=await getFunciton() 
console.log(res)

等价于：
getFunciton().then(res=>{
    console.log(res)
})
```   
4. 错误机制的处理
    * 用try...catch包住可能出错的地方
    * 直接在后面添加.catch(err=>{})

## 十二. class类 
1. es5中创建一个类
    * 方法：通过构造一个函数，然后用new 命令创建一个实例，这个实例就是一个类了,在调用
    * 语法
```
function people(user,info){
    通过this方法来创建一些公有的属性
    this.user=user
    this.info=info
}

通过原型来创建一些公有的属性
people.prototype.showName=function(){
    console.log(this.user)
}

通过new来创建实例
var peo=new people('baixi',18)
console.log(peo);
console.log(po.user);
po.showName();
```
2. es6中创建一个类
    * 直接使用class关键字,并执行constructor函数（构造函数实例化的时候自动执行），然后用new 命令创建一个实例
    * 语法：
```
1.直接使用class关键字创建类
class student{
    constructor(uname,age){
        this.uname=uname
        this.age=age
    }
    showAge(){
        console.log(this.age)
    }
}
student.prototype.show=function(){
    console.log(this.uname);
  }

2. 实例化
var stu=new student('beixi',20)
console.log(stu);
console.log(stu.uname);
stu.showAge()
stu.show()
```

3. 继承
```
1. 创建父类
class student{
  constructor(uname,age) {  //构造函数实例化的时候自动执行
    this.uname=uname;
    this.age=age
  }
  showAge(){
    console.log(this.age);
  }
}
student.prototype.show=function(){
  console.log(this.uname);
}

// 继承，创建子类
class smallstudent extends student{
  // 实现子类自己的一些方法
  constructor(uname,age,sex) {
    super(uname,age);  // 用super父元素的constructor()写下来
    this.sex=sex
  }
}

3. 子类实例化，父类不用实例化
var small=new smallstudent("甜心",7,"女")
console.log(small);
small.showAge();
small.show()
```

## 十三. var,let,const
1. var声明的变量是全局变量或者是局部变量,let和const声明的变量是块级变量在{}中
2. var声明的变量具有变量提升（会被提升到代码头部）
3. let声明的变量允许重新赋值，const声明的变量不允许重新赋值
4. let和const声明的变量不允许重复声明
5. 暂时性死区：在使用let和const声明变量之前，这个变量都是不可用的
6. 注意：const声明的常量指的是内存地址不能被修改，但是是可以改变内部属性的
```
const obj={
    name:"james",
    age:36,
    height:203
  }
obj.name="kobe";
这里就是const声明的常量obj不能改变，但是可以改变obj内部的属性值
```

## 十四.模板字符串
1. 用反引号包裹，然后用${}的形式引用
2. 语法：`${}`

## 十五.解构有哪几类
1. 对象解构
2. 数组解构
3. 混合解构
4. 参数解构