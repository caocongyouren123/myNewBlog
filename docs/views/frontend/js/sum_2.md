---
title: "Q&A宝典-JS篇-2"
date: 2020-10-10
visitor: 28
categories:
 - javascript
tags:
- 复习,面试
isShowComments: true
sidebar: true
---

<Boxx/>

# 第二篇 
## 一.js中的垃圾回收机制
1. 概述：防止内存泄漏，该机制就是间歇的不定期寻找不再使用的变量，并释放掉它们所指向的内存。
2. 回收方式：
    * 标记清除：当变量进入执行环境（函数声明）的时候，垃圾回收器将其标记为“进入环境”，当它离开
                执行环境（函数执行结束）的时候，将其标记为“离开环境”，然后去掉环境变量以及被环境
                变量所引用的变量的标记，在完成这些之后仍然存在的标记就是要删除的变量。
    * 引用计数：低版本IE浏览器中这种方法常常会引起内存泄漏，当声明一个变量并且将一个引用类型赋值给
                该变量的时候，这个值的引用次数加1，当这个变量指向其他引用类型时，这个值就减1。当引用
                次数为零时就会被回收。   
3. 内存泄漏：不再拥有或需要任何对象（数据）之后，他们仍然存在于内存之中。

## 二.列举DOM节点
1. 文档节点：Document
2. 元素节点：Element
3. 属性节点：Attribute
4. 文本节点：Text

## 三.DOM中创建、添加、移除、替换、插入、查找
1. 创建：
    * createDocumentFragment()   // 创建一个DOM片段
    * createElement()   // 创建一个元素
    * createTextNode()  // 创建一个文本节点
2. 添加、移除、替换、插入：
    * appendChild()
    * removeChild()
    * replaceChild()
    * insertBefore()
3. 查找：
    *  document.querySelector('.class'): 返回类名为class的节点，如果有多个则返回第一个
       可以是id选择器，元素选择器等。
    * document.querySelectorAll('.class'): 返回类为class的所有节点
    * document.ElementById(): 返回指定id的节点
    * document.ElementsByClassName(): 返回指定类名的节点
    * document.ElementsByTagName(): 返回指定标签属性的元素节点
    * document.ElementsByName(): 返回拥有name属性的html元素

## 四.js的延迟加载
1. defer:
    * 会在DOM加载完成之后才会执行js脚本，防止外部文件过大或网络卡顿造成的文件阻塞。
    * 会按照页面上script标签的顺序执行
2.async:
    * 异步执行，不会按照页面上script标签的顺序执行，提高运行效率。
    
## 五.为什么说函数是第一类对象
1. 可以作为参数传递给其他函数
2. 可以作为其他函数的返回值，分配给变量
3. 可以存在于数据结构之中

## 六.attribute和property的区别
1. attribute是html文档元素拥有的属性
2. property是js对象拥有的属性

## 七.判断js数据类型
1. typeof()
2. A instanceof B
3. Object.prototype.toString.call()
4. typeof()和instanceof的区别：
    * typeof()是用来检测数据类型的，返回基本数据类型
    * instanceof是用来判断前后数据类型的关联性，返回布尔值
5.typeof(arr),typeof(null)=>"object"   typeof(undefined)=>"undefined"  typeof(NaN)=>"number"

## 八.判断一个js变量是否是数组
1. arr instanceof Array
2. 原型链办法：arr.__proto__.constructor===Array
3. 通用办法：Object.prototype.toString.call(arr)==='[object Array]'

## 九.浅谈for in和for of
1. for...in用于遍历数组和对象（多数用于对象）for...of用于遍历数组
2. for...in遍历的是索引，键名，for...of遍历的是值

## 十.事件委托（代理）
1. 描述：把原本需要绑定的事件委托给父元素，让父元素负责事件的监听。
2. 原理：事件冒泡
3. 优点：
    * 减少事件数量，提高性能
    * 预测未来元素，新添加的元素可以触发该事件
4. 事件：当用户或者浏览器与页面产生交互的时候，产生可以被javascript侦测到的交互行为称为事件

## 十一.字符串和数字间的转换
1. 字符串转数字：
    * Number('123') :将一个字符串转换为整型或者浮点型，只能用于十进制,字符串中不能出现非数字字符
    * parseInt('123'):全局函数只能解析整数
    * parseFloat('123.3'):全局函数可以解析整数和浮点数
2. 数字转字符串：
    * number.toString(radix):radix在2-36之间，默认是10，代表十进制
    * number.toFixed(a):小数点后精确到a位
    * number.toExponential(a):用科学计数法，小数点后精确到a位
    * number.toPrecision(a):a表示指定的有效数字位数
    
## 十二 .alert,confirm,prompt
1. alert: 警告消息框，给出'确认'按钮，会阻塞后面程序
2. confirm: 确认消息框，给出"确认","取消"两个按钮，分别点击会触发不同效应。会阻塞后面程序
3. prompt: 提示消息框，提供一个可以供用户输入的文本字段，给出"确认","取消"两个按钮，会阻塞后面程序

## 十三.window.onload和onDocumentReady
1. window.onload: 用于在网页加载完毕之后立刻执行的操作
```
window.onload=function(){   // 等页面加载（渲染）完毕再依次执行fun1(),fun2(),fun3()
    fun1();
    fun2();
    fun3()
}
```
2. onDocumentReady: 用于在DOM结构绘制完毕之后再执行。不必等待加载渲染完毕（例如样式的渲染，外部文件的执行）

## 十四.构造函数和普通函数
1. 构造函数：主要用来创建对象时初始化对象，经常和new运算符一起使用。
2. 区别：
    * 构造函数只能由new关键字调用
    * 构造函数可以创建实例化对象
    * 构造函数是类的标志
    
## 十五.自执行函数
1. 定义：声明一个匿名函数，可以立即调用这个匿名函数
2. 应用：创建一个独立的作用域，一般用于创建框架，插件等场景
3. 优点：
    * 隔离作用域，避免污染
    * 避免闭包造成的引用变量无法释放
    * 利用立即执行的特性，返回需要的业务函数或对象
    
## 十六.js的内置对象
1. Object
2. Array
3. String
4. Number
5. Boolean
6. Date
7. Function

## 十七.http,https
1. http: 是使用最广泛的超文本传输协议，通常承载于TCP之上，并不是很安全，端口是80
2. https: 是加密的以安全为主的http通道，端口是443，在http和tcp之间添加一个安全协议层（SSL或TSL）
3. 工作原理：在前台中通过ajax在js中创建XMLHttpRequest()对象，向后台发送请求。在后台接收到请求之后执行相应的逻辑并将数据返回给前台
4. 特点：支持客户/服务器模式，简单、快速、灵活。

## 十八.TCP三次握手四次挥手
1. 三次握手：（建立连接的过程）
    * 客户端->服务器（发送请求告诉服务器准备接受）
    * 服务器->客户端（服务器反馈给客户端已经准备好了）
    * 客户端->服务器（开始发送数据）
2. 四次挥手：（关闭连接的过程）
    * 客户端->服务器（请求报头发送完毕，你准备关闭）
    * 服务器->客户端（请求报头接收完毕，你准备关闭）
    * 服务器->客户端（响应报头发送完毕，你准备关闭）
    * 客户端->服务器（响应报头接收完毕，你准备关闭）
    
## 十九.TCP和UDP
相同点：都是传输层通信协议。
不同点：
1. TCP是面向连接的，UDP不需要建立连接
2. TCP适合大量数据交换安全，UDP不安全
3. TCP面向字节流，UDP面向报文
4. TCP消息到达网络另一端有序，UDP无需
5. TCP传输速度慢，UDP速度快
6. TCP只能是一对一，UDP可以是一对一，也可以是一对多。
7. TCP有流量控制和拥塞控制，UDP没有

## 二十.状态码
1. 200 请求成功，一般用于get请求和post请求
2. 201 请求成功并且创建了新的资源
3. 202 接收请求但是没有做出处理
4. 203 未授权信息
5. 204 无内容
6. 205 重置内容
7. 301 被请求的资源已经被永久的移动到了新的位置
7. 302 请求的资源现在临时从不同的url响应请求（重定向）
8. 400 客户端语法错误请求无效
9. 401 当前请求需要用户验证
10. 403 服务器已经接收请求，但是拒绝访问
11. 404 服务器无响应，找不到响应内容
12. 总结：状态码就是用来反映前台是否做好了接收后台数据的准备。

## 二十一.get和post
1. get请求参数通过url传递（?开头&连接），参数暴露出来不安全；post请求参数写在请求体中（由new FormData()创建的表单数据当中并通过append来添加数据），参数隐藏，安全。
2. get请求参数长度有限制，post请求没有
3. get请求产生一个数据包，把http head和data一并发送给客户端。post请求先发送head在发送data,因此产生两个数据包。
4. get请求只能进行url编码，post请求支持多种编码。

## 二十二.浏览器缓存
1. 强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。
2. 协商缓存：浏览器发送请求到服务器，服务器判断是否可使用本地缓存。

## 二十三.跨域
1. 同源策略：
    * 是浏览器的安全策略
    * 要求协议名，域名，端口号必须一致
    * 只要违背了同源策略就会产生跨域现象
2. 解决跨域：
    * 后台法：由于后台不会产生跨域，因此可以在后台中请求跨域文件。例如在后台php中通过file_get_contents('跨域路径')来获取跨域路径，然后再前台请求
              这一路径。
    * jsonp: 通过动态的创建一个script标签，在请求一个带参网址（get请求）。
    * cors: 使用自定义的http头部让浏览器与服务器进行沟通，本质上是后端工作。
    * postMessage: 一种windows属性。
    * Nginx(恩静埃克斯): 是一款极其强大的web服务器，优点是轻量级，启动快，高并发。主要是通过方向代理的办法来实现跨域
    
## 二十四.函数节流
* 一个函数执行一次之后，只有大于设定的执行周期才会执行第二次。

## 二十五.函数防抖
* 当一个函数需要被频繁的调用，只执行最后一次，前面的均不生效。

## 二十六.从输入url到页面加载完成发生了什么
1. DNS解析（域名解析）
2. TCP三次握手
3. 发送http请求
4. 接受响应
5. 浏览器解析渲染页面
6. 断开连接

## 二十七.深拷贝和浅拷贝
1. 浅拷贝：只是引用层面上的拷贝，两者还是指向同一内存地址，当改变一个的时候另一个也会改变。
2. 深拷贝：通过递归的方式复制所有属性，两者指向不同的内存地址，是真正意义上的拷贝，当改变一个的时候另一个不会改变。

## 二十八.数组的扁平化
```
方法一：
const arr = [11, [22, 33], [44, 55], 66];
flatarr=arr.join().split(',');
var a=[];
for(var i=0;i<flatarr.length;i++){
    a.push(Number(flatarr[i]));
}
console.log(a);

方法二：
const arr = [11, [22, 33], [44, 55], 66];
flatarr=arr.toString().split(',');
var a=[];
for(var i=0;i<flatarr.length;i++){
    a.push(Number(flatarr[i]));
}
console.log(a);

方法三：
const arr = [11, [22, [33,1,2]], [44, 55], 66];
console.log(arr.flat(Infinity));
注：flat(1)表示展开一层，2表示展开两层，Infinity表示不管多少层嵌套都展开成一位数组。
```